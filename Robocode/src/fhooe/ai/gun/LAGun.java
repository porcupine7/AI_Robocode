package fhooe.ai.gun;

import robocode.AdvancedRobot;
import robocode.ScannedRobotEvent;
import robocode.util.Utils;

import java.awt.geom.Point2D;
import java.awt.geom.Rectangle2D;
import java.util.ArrayList;

/**
 * Created by Christian on 14.04.2015.
 */
public class LAGun implements Gun{
    final static double BULLET_DAMAGE=10;
    final AdvancedRobot mRobot;
    static double enemyEnergy;
    ArrayList<LAGun.MovementWave> moveWaves=new ArrayList<LAGun.MovementWave>();

    ArrayList<LAGun.GunWave> gunWaves=new ArrayList<LAGun.GunWave>();
    /*
     * This Array will hold the most recent movement angle for every lateral velocity segment;
     */
    static double gunAngles[]=new double[16];
    public LAGun(AdvancedRobot _robot){
        mRobot=_robot;
        enemyEnergy=100;
    }

    @Override
    public double estimateFirePower(double _enemyDistance) {
        double firePower = (BULLET_MAX_POWER - (_enemyDistance/MAXIMAL_ENEMY_DISTANCE)*BULLET_MAX_POWER);
        return firePower < BULLET_MIN_POWER ? BULLET_MIN_POWER : firePower;
    }

    @Override
    public void scannedRobot(ScannedRobotEvent e){
        double absBearing=e.getBearingRadians()+mRobot.getHeadingRadians();
        //chooseDirection(GFTUtils.project(new Point2D.Double(mRobot.getX(),mRobot.getY()),e.getDistance(),absBearing));

		/*
		 * logs a gun wave when we fire;
		 */
        if(mRobot.getGunHeat()==0){
            logFiringWave(e);
        }
		/*
		 * This method checks our waves to see if they have reached the enemy yet.
		 */
        checkFiringWaves(GFTUtils.project(new Point2D.Double(mRobot.getX(),mRobot.getY()),e.getDistance(),absBearing));

		/*
		 * Aiming our gun and firing
		 */
        mRobot.setTurnGunRightRadians(Utils.normalRelativeAngle(absBearing-mRobot.getGunHeadingRadians())
                +gunAngles[8+(int)(e.getVelocity()*Math.sin(e.getHeadingRadians()-absBearing))]);
        mRobot.setFire(estimateFirePower(e.getDistance()));

        mRobot.setTurnRadarRightRadians(Utils.normalRelativeAngle(absBearing-mRobot.getRadarHeadingRadians())*2);

    }

    /*
 * This method looks at all the directions we could go, then rates them based on how close they will take us
 * to simulated bullets fired with both linear and head-on targeting generated by the waves we have logged.
 * It is the core of our movement.
 */
    public void chooseDirection(Point2D.Double enemyLocation){
        MovementWave w;
        //This for loop rates each angle individually
        double bestRating=Double.POSITIVE_INFINITY;
        for(double moveAngle=0;moveAngle<Math.PI*2;moveAngle+=Math.PI/16D){
            double rating=0;

            //Movepoint is position we would be at if we were to move one robot-length in the given direction.
            Point2D.Double movePoint=GFTUtils.project(new Point2D.Double(mRobot.getX(),mRobot.getY()),36,moveAngle);

			/*
			 * This loop will iterate through each wave and add a risk for the simulated bullets on each one
			 * to the total risk for this angle.
			 */
            for(int i=0;i<moveWaves.size();i++){
                w=moveWaves.get(i);

                //This part will remove waves that have passed our robot, so we no longer keep taking into account old ones
                if(new Point2D.Double(mRobot.getX(),mRobot.getY()).distance(w.origin)<(mRobot.getTime()-w.startTime)*w.speed+w.speed){
                    moveWaves.remove(w);
                }
                else{
					/*
					 * This adds two risks for each wave: one based on the distance from where a head-on targeting
					 * bullet would be, and one for where a linear targeting bullet would be.
					 */
                    rating+=1D/Math.pow(movePoint.distance(GFTUtils.project(w.origin,movePoint.distance(w.origin),w.angle)),2);
                    rating+=1D/Math.pow(movePoint.distance(GFTUtils.project(w.origin,movePoint.distance(w.origin),w.angle+w.latVel)),2);
                }
            }
            //This adds a risk associated with being to close to the other robot if there are no waves.
            if(moveWaves.size()==0){
                rating=1D/Math.pow(movePoint.distance(enemyLocation),2);
            }
            //This part tells us to go in the direction if it is better than the previous best option and is reachable.
            if(rating<bestRating&&new Rectangle2D.Double(50,50,mRobot.getBattleFieldWidth()-100,mRobot.getBattleFieldHeight()-100).contains(movePoint)){
                bestRating=rating;
				/*
				 * These next three lines are a very codesize-efficient way to
				 * choose the best direction for moving to a point.
				 */
                int pointDir;
                mRobot.setAhead(1000*(pointDir=(Math.abs(moveAngle-mRobot.getHeadingRadians())<Math.PI/2?1:-1)));
                mRobot.setTurnRightRadians(Utils.normalRelativeAngle(moveAngle + (pointDir == -1 ? Math.PI : 0) - mRobot.getHeadingRadians()));
            }
        }
    }

    /*
 * This method will log a firing wave.
 */
    public void logFiringWave(ScannedRobotEvent e){
        GunWave w=new GunWave();
        w.absBearing=e.getBearingRadians()+mRobot.getHeadingRadians();
        w.speed=20-estimateFirePower(e.getDistance())*3;
        w.origin=new Point2D.Double(mRobot.getX(),mRobot.getY());
        w.velSeg=(int)(e.getVelocity()*Math.sin(e.getHeadingRadians()-w.absBearing));
        w.startTime=mRobot.getTime();
        gunWaves.add(w);
    }
    /*
     * This method checks firing waves to see if they have passed the enemy yet.
     */
    public void checkFiringWaves(Point2D.Double ePos){
        GunWave w;
        for(int i=0;i<gunWaves.size();i++){
            w=gunWaves.get(i);
            if((mRobot.getTime()-w.startTime)*w.speed>=w.origin.distance(ePos)){
                gunAngles[w.velSeg+8]=Utils.normalRelativeAngle(Utils.normalAbsoluteAngle(Math.atan2(ePos.x-w.origin.x, ePos.y-w.origin.y))-w.absBearing);
                gunWaves.remove(w);
            }
        }
    }

    public class GunWave{
        double speed;
        Point2D.Double origin;
        int velSeg;
        double absBearing;
        double startTime;
    }

    /*
     * This class is the data we will need to use our movement waves.
     */
    public static class MovementWave{
        Point2D.Double origin;
        double startTime;
        double speed;
        double angle;
        double latVel;
    }
}
